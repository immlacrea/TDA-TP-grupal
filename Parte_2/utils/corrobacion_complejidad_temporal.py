# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eklY0P2eX2ejqj6lGglSJqYA2nHTV6ES
"""

from random import seed
import time

from matplotlib import pyplot as plt
import seaborn as sns
import numpy as np
import scipy as sp

from sophia_and_mateo_game import util_sophia_measure

# Siempre seteamos la seed de aleatoridad para que los # resultados sean reproducibles
seed(12345)
np.random.seed(12345)

sns.set_theme()

def get_random_array(size):
    return np.random.randint(0, 1001, size)

def time_algorithm(algorithm, sizes, data_generator):
    results = []

    for size in sizes:
        times = []
        # Genera los datos de entrada
        data = data_generator(size)
        for _ in range(1):
            start = time.time()
            algorithm(data)  # Ejecuta el algoritmo
            elapsed_time = time.time() - start
            times.append(elapsed_time)  # Guarda el tiempo de ejecución
        avg_time = np.mean(times)
        results.append(avg_time)
    return results

# 3. Configuración de tamaños de entrada
x = np.linspace(5, 10_000, 20).astype(int)  # Tamaños de entrada

# 4. Medir tiempos para la función sophia_algorithm
results = time_algorithm(util_sophia_measure, x, lambda s: get_random_array(s))

# 5. Graficar los resultados
plt.figure(figsize=(10, 6))
plt.plot(x, results, label="Medición")
plt.xlabel("Tamaño del array de entrada")
plt.ylabel("Tiempo de ejecución (segundos)")
plt.title("Complejidad temporal de Algoritmo Dinamico")
plt.legend()
plt.grid()
plt.show()

#Calculo del error cuadratico con un ajuste cuadratico
f = lambda x, c1, c2: c1 * x**2 + c2

c, pcov = sp.optimize.curve_fit(f, x, results)

print(f"c_1 = {c[0]}, c_2 = {c[1]}")
r = np.sum((c[0] * x**2 + c[1] - results)**2)
print(f"Error cuadrático total: {r}")

ss_res = np.sum((results - (c[0] * x**2 + c[1]))**2)  # Suma de residuos
ss_tot = np.sum((results - np.mean(results))**2)      # Suma total
r_squared = 1 - (ss_res / ss_tot)
print(f"R^2: {r_squared}")

# Crear la figura y los ejes
fig, ax = plt.subplots(figsize=(10, 6))

# Graficar los datos originales
ax.plot(x, results, label="Datos originales")

# Graficar la curva ajustada
ax.plot(x, [c[0] * n**2 + c[1] for n in x], 'r--', label="Ajuste")

# Configurar etiquetas y título
ax.set_xlabel("Tamaño de entrada")
ax.set_ylabel("Tiempo de ejecución (segundos)")
ax.set_title("Ajuste cuadrático de la complejidad temporal")
ax.legend()
ax.grid()

# Mostrar el gráfico
plt.show()

#Grafico del error absoluto para cada tamaño de entrada
ax: plt.Axes
fig, ax = plt.subplots()
errors = [np.abs(c[0] * n**2 + c[1] - r) for n, r in zip(x, results)]
ax.plot(x, errors)
ax.set_title('Error de ajuste')
ax.set_xlabel('Tamaño del array')
ax.set_ylabel('Error absoluto (s)')
None